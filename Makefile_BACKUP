# ===============================
# Danipa Fintech Platform - Makefile
# Unified Application & Vault Management (compose-friendly vault certs)
# ===============================
SHELL := /bin/bash
.DEFAULT_GOAL := help
.ONESHELL:

ifneq (,$(wildcard .env))
include .env
export
endif

# ---------- Compose / Network ----------
COMPOSE ?= docker compose
NET     ?= danipa-net
VAULT_SERVICE ?= vault            # compose service name (matches your original flow)

# ---------- Core URLs ----------
VAULT_ADDR        ?= http://vault:8200
CONFIG_URL        ?= http://config-server:8088
EUREKA_URL        ?= http://eureka-server:8761
FINTECH_URL       ?= http://fintech-service:8080
KEYCLOAK_URL      ?= http://keycloak:8080

# ---------- TLS / Files ----------
VAULT_HOST_HTTPS  ?= https://vault.local.danipa.com:18300
VAULT_CACERT      ?= infra/vault/tls/root_ca.crt
TLS_DIR           ?= infra/vault/tls

# ---------- Secrets / Scripts ----------
SEEDS_DIR         ?= infra/vault/seeds
SCRIPTS_DIR       ?= infra/vault/scripts
WRITE_SECRETS     ?= $(SCRIPTS_DIR)/write-secrets.sh
DEV_JSON          ?= dev.json
UNSEAL_KEY_FILE   ?= infra/vault/keys/vault-unseal.key

# ---------- Env / Misc ----------
VAULT_TOKEN       ?= $(shell jq -r '.root_token // empty' infra/vault/keys/vault-keys.json 2>/dev/null)
CURL_SILENT       ?= -fsS --connect-timeout 3 --max-time 5

# ---------- Step CA (cert issuance) ----------
# The CA certificate’s DNS name must match this host (used for SNI).
STEP_CA_HOST ?= step-ca.local.danipa.com
# Compose service name that runs the CA:
STEP_CA_SVC  ?= step-ca
STEP_CA_PORT ?= 9000

PROV            ?= admin
PROV_PASS       ?=            # optional if you also provide PROV_PASS_FILE
PROV_PASS_FILE  ?=            # alternative to PROV_PASS: path to a local file with the password
VAULT_CERTS_DIR ?= /vault/config/certs

# Safety: strip any accidental whitespace from host/port
STEP_CA_HOST_STRIPPED := $(strip $(STEP_CA_HOST))
STEP_CA_PORT_STRIPPED := $(strip $(STEP_CA_PORT))

# ---------- Helpers ----------
define wait_http
@echo ">> Waiting for $(1) ..."
@i=0; \
until curl $(CURL_SILENT) -o /dev/null -w '%{http_code}\n' "$(1)/actuator/health" | \
  grep -Eq '^(2|3)'; do \
  i=$$((i+1)); if [ $$i -gt 60 ]; then echo "!! Timeout waiting for $(1)"; exit 1; fi; \
  sleep 2; \
done; \
echo "OK: $(1)"
endef

define hdr
@echo -e "\n=== $(1) ===\n"
endef

# ---------- Help ----------
.PHONY: help
help:
	@awk 'BEGIN {FS = ":.*##"; printf "\nDanipa Fintech Platform - Makefile\n\nUsage:\n  make \033[36m<target>\033[0m\n\nTargets:\n"} \
	/^[a-zA-Z0-9_\-]+:.*##/ { printf "  \033[36m%-28s\033[0m %s\n", $$1, $$2 } \
	/^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0,5) } ' $(MAKEFILE_LIST)

##@ Docker / Compose
.PHONY: network
network: ## Create external docker network (idempotent)
	$(call hdr,Create network $(NET))
	@docker network create $(NET) 2>/dev/null || true
	@docker network ls | grep -E '\b$(NET)\b' || (echo "!! Network not found" && exit 1)

.PHONY: up
up: network ## Bring up all services (detached)
	$(call hdr,Compose UP)
	$(COMPOSE) up -d

.PHONY: up-core
up-core: network ## Bring up core stack
	$(call hdr,Compose UP core)
	$(COMPOSE) up -d vault keycloak config-server eureka-server fintech-service postgres-dev redis kafka

.PHONY: down
down: ## Stop and remove containers
	$(call hdr,Compose DOWN)
	$(COMPOSE) down

.PHONY: ps
ps: ## Show compose services
	$(COMPOSE) ps

.PHONY: logs
logs: ## Tail logs: make logs SERVICE=fintech-service
	@test -n "$(SERVICE)" || (echo "Usage: make logs SERVICE=<name>"; exit 1)
	$(COMPOSE) logs -f $(SERVICE)

.PHONY: bash
bash: ## Shell into a running container: make bash SERVICE=fintech-service
	@test -n "$(SERVICE)" || (echo "Usage: make bash SERVICE=<name>"; exit 1)
	@$(COMPOSE) exec $(SERVICE) bash

.PHONY: restart
restart: ## Restart service: make restart SERVICE=fintech-service
	@test -n "$(SERVICE)" || (echo "Usage: make restart SERVICE=<name>"; exit 1)
	$(COMPOSE) up -d --no-deps --force-recreate $(SERVICE)

.PHONY: compose-config
compose-config: ## Print merged compose file config (debug)
	$(COMPOSE) config

.PHONY: clean-volumes
clean-volumes: ## Remove containers + anonymous volumes
	$(COMPOSE) down -v

.PHONY: prune
prune: ## Prune dangling images, networks, volumes (DANGEROUS)
	@docker system prune -f
	@docker volume prune -f
	@docker network prune -f

##@ Environment
.PHONY: env
env: ## Print key environment variables
	@echo "APP_ENV=$(APP_ENV)"
	@echo "CONFIG_URL=$(CONFIG_URL)"
	@echo "EUREKA_URL=$(EUREKA_URL)"
	@echo "FINTECH_URL=$(FINTECH_URL)"
	@echo "VAULT_ADDR=$(VAULT_ADDR)"
	@echo "VAULT_TOKEN=$(if $(VAULT_TOKEN),[set],[missing])"
	@echo "JAVA_TOOL_OPTIONS=$(JAVA_TOOL_OPTIONS)"
	@echo "KAFKA=$(SPRING_KAFKA_BOOTSTRAP_SERVERS)"

##@ Health Checks
.PHONY: health
health: health-vault health-config health-eureka health-fintech ## Run all service health checks

.PHONY: health-vault
health-vault: ## Check Vault health (HTTP API)
	$(call hdr,Vault Health)
	@curl $(CURL_SILENT) "$(VAULT_ADDR)/v1/sys/health" | jq . || true

.PHONY: health-vault-https
health-vault-https: ## Check Vault health via local HTTPS with custom CA
	$(call hdr,Vault Health (HTTPS + custom CA))
	@curl $(CURL_SILENT) --cacert "$(VAULT_CACERT)" "$(VAULT_HOST_HTTPS)/v1/sys/health" | jq . || true

.PHONY: health-config
health-config: ## Spring Cloud Config health
	$(call hdr,Config Server Health)
	@curl $(CURL_SILENT) "$(CONFIG_URL)/actuator/health" | jq . || true

.PHONY: health-eureka
health-eureka: ## Eureka health
	$(call hdr,Eureka Health)
	@curl $(CURL_SILENT) "$(EUREKA_URL)/actuator/health" | jq . || true

.PHONY: health-fintech
health-fintech: ## Fintech service health
	$(call hdr,Fintech Service Health)
	@curl $(CURL_SILENT) "$(FINTECH_URL)/actuator/health" | jq . || true

##@ Waiters
.PHONY: wait-core
wait-core: ## Wait for core services to be healthy
	$(call wait_http,$(CONFIG_URL))
	$(call wait_http,$(EUREKA_URL))
	$(call wait_http,$(FINTECH_URL))

##@ Vault & Secrets
.PHONY: vault-token
vault-token: ## Print current VAULT_TOKEN source (does not echo token value)
	@echo "VAULT_TOKEN=$(if $(VAULT_TOKEN),[set],[missing])  (source: infra/vault/keys/vault-keys.json if present)"

.PHONY: secrets-dev
secrets-dev: ## Seed secrets for DEV using write-secrets.sh (reads dev.json)
	$(call hdr,Seeding DEV secrets to Vault)
	@test -x "$(WRITE_SECRETS)" || (echo "!! $(WRITE_SECRETS) not found or not executable"; exit 1)
	@test -f "$(DEV_JSON)" || (echo "!! $(DEV_JSON) not found"; exit 1)
	@test -n "$(VAULT_TOKEN)" || (echo "!! VAULT_TOKEN not set and not found at infra/vault/keys/vault-keys.json"; exit 1)
	TOKEN="$(VAULT_TOKEN)" ENVS=dev "$(WRITE_SECRETS)"

.PHONY: secrets-staging
secrets-staging: ## Seed secrets for STAGING (expects stg json if used by script)
	@test -x "$(WRITE_SECRETS)" || (echo "!! $(WRITE_SECRETS) not found or not executable"; exit 1)
	@test -n "$(VAULT_TOKEN)" || (echo "!! VAULT_TOKEN not set"; exit 1)
	TOKEN="$(VAULT_TOKEN)" ENVS=staging "$(WRITE_SECRETS)"

.PHONY: secrets-prod
secrets-prod: ## Seed secrets for PROD (CAUTION)
	@test -x "$(WRITE_SECRETS)" || (echo "!! $(WRITE_SECRETS) not found or not executable"; exit 1)
	@test -n "$(VAULT_TOKEN)" || (echo "!! VAULT_TOKEN not set"; exit 1)
	TOKEN="$(VAULT_TOKEN)" ENVS=prod "$(WRITE_SECRETS)"

.PHONY: secrets-verify
secrets-verify: ## Dry-run: verify Vault writes without changing data
	@test -x "$(WRITE_SECRETS)" || (echo "!! $(WRITE_SECRETS) not found or not executable"; exit 1)
	@test -n "$(VAULT_TOKEN)" || (echo "!! VAULT_TOKEN not set"; exit 1)
	TOKEN="$(VAULT_TOKEN)" VERIFY_ONLY=true ENVS=dev,staging,prod "$(WRITE_SECRETS)"

.PHONY: kv-list
kv-list: ## List top-level KV v2 paths
	@test -n "$(VAULT_TOKEN)" || (echo "!! VAULT_TOKEN not set"; exit 1)
	@curl $(CURL_SILENT) -H "X-Vault-Token: $(VAULT_TOKEN)" "$(VAULT_ADDR)/v1/secret/metadata?list=true" | jq . || true

##@ Vault TLS & Unseal
# SAN handling: defaults + optional EXTRA_SANS you can append at CLI.
CN          ?= vault.local.danipa.com
SANS        ?= vault.local.danipa.com vault localhost 127.0.0.1
EXTRA_SANS  ?=
SANS_FINAL  := $(SANS) $(EXTRA_SANS)

VAULT_CERTS_DIR ?= /vault/config/certs
VAULT_SERVICE   ?= vault
TLS_DIR         ?= infra/vault/tls

# Use the working script to issue certs
VAULT_CERT_SCRIPT ?= infra/vault/scripts/cert/vault_cert.sh

.PHONY: vault-cert
vault-cert: ## Issue Vault TLS cert via working script, copy into Vault container, and recreate service
	@echo ">> Issuing Vault cert for CN=$(CN)"
	@echo ">> SANs: $(SANS_FINAL)"
	@test -x "$(VAULT_CERT_SCRIPT)" || (echo "!! $(VAULT_CERT_SCRIPT) not found or not executable"; exit 1)
	SANS="$(SANS_FINAL)" "$(VAULT_CERT_SCRIPT)" issue "$(CN)"

	@# Sanity-check the produced cert
	@openssl x509 -in "$(TLS_DIR)/server.crt" -noout -subject -issuer -dates -ext subjectAltName || { echo "!! openssl failed; bad cert?"; exit 2; }

	@echo ">> Ensuring cert directory exists inside Vault ..."
	@CID="$$(docker compose ps -q $(VAULT_SERVICE))"; test -n "$$CID" || { echo "!! Vault container not running"; exit 2; }; \
	docker exec -t $$CID sh -lc 'mkdir -p "$(VAULT_CERTS_DIR)"'

	@echo ">> Copying cert and key into Vault ..."
	@CID="$$(docker compose ps -q $(VAULT_SERVICE))"; \
	docker cp "$(TLS_DIR)/server.crt" $$CID:$(VAULT_CERTS_DIR)/server.crt; \
	docker cp "$(TLS_DIR)/server.key" $$CID:$(VAULT_CERTS_DIR)/server.key

	@echo ">> Recreating Vault service to pick up new certs ..."
	docker compose up -d --no-deps --force-recreate $(VAULT_SERVICE)

	@echo ">> Checking Vault API health (TLS) ..."
	curl -sS --cacert "$(TLS_DIR)/root_ca.crt" \
	  --resolve "$(CN)":18300:127.0.0.1 \
	  https://$(CN):18300/v1/sys/health | jq

.PHONY: vault-cert-dry-run
vault-cert-dry-run: ## Issue cert only using the working script (no copy/restart)
	@echo ">> Dry-run issuance for CN=$(CN)"
	@echo ">> SANs: $(SANS_FINAL)"
	@test -x "$(VAULT_CERT_SCRIPT)" || (echo "!! $(VAULT_CERT_SCRIPT) not found or not executable"; exit 1)
	SANS="$(SANS_FINAL)" "$(VAULT_CERT_SCRIPT)" issue "$(CN)"
	@echo "✓ Certs are on host at $(TLS_DIR)/server.crt and $(TLS_DIR)/server.key (Vault untouched)"
	@$(MAKE) vault-cert-verify

.PHONY: vault-cert-verify
vault-cert-verify: ## Show CN, SANs, issuer and validity of the last issued cert
	@openssl x509 -in "$(TLS_DIR)/server.crt" -noout -subject -issuer -dates -ext subjectAltName || true

.PHONY: vault-status
vault-status: ## Show Vault seal status (ignoring TLS verification)
	@echo ">> Checking Vault status (sealed/unsealed)..."
	docker compose exec -T $(VAULT_SERVICE) sh -lc 'vault status -address=https://127.0.0.1:8200 -tls-skip-verify || true'

.PHONY: vault-unseal
vault-unseal: ## Unseal Vault non-interactively (UNSEAL_KEY env var or infra/vault/keys/vault-unseal.key)
	@echo ">> Unsealing Vault (non-interactive)..."
	@KEY="$${UNSEAL_KEY:-$$(tr -d '\r\n' < infra/vault/keys/vault-unseal.key 2>/dev/null)}"; \
	if [ -z "$$KEY" ]; then \
	  echo "ERROR: unseal key is empty. Set UNSEAL_KEY or put the key in infra/vault/keys/vault-unseal.key"; exit 1; \
	fi; \
	docker compose exec -T $(VAULT_SERVICE) sh -lc "vault operator unseal -address=https://127.0.0.1:8200 -tls-skip-verify $${KEY}"

.PHONY: vault-health
vault-health: ## Check Vault API health over TLS (with SNI + CA pinning)
	@echo ">> Checking Vault API health for CN=$(CN)..."
	curl -sS --cacert "$(TLS_DIR)/root_ca.crt" \
	  --resolve "$(CN)":18300:127.0.0.1 \
	  https://$(CN):18300/v1/sys/health | jq

##@ Hosts helpers
HOSTS_SNIPPET ?= infra/hosts/hosts-snippet

.PHONY: hosts-snippet
hosts-snippet: ## Generate a hosts file snippet with Danipa domains (idempotent content)
	@mkdir -p infra/hosts
	@cat > $(HOSTS_SNIPPET) <<-'EOF'
	# Danipa Fintech Platform (local dev)
	127.0.0.1 vault.local.danipa.com keycloak.local.danipa.com \
	          config.local.danipa.com eureka.local.danipa.com \
	          fintech.local.danipa.com kibana.local.danipa.com \
	          pgadmin.local.danipa.com step-ca.local.danipa.com
	EOF
	@echo "Wrote $(HOSTS_SNIPPET)"

.PHONY: hosts-patch
hosts-patch: hosts-snippet ## Patch the system hosts file (Linux/mac: automatic; Windows: print instructions)
	@os=$$(uname -s || echo Unknown); \
	if [ "$$os" = "Darwin" ] || [ "$$os" = "Linux" ]; then \
	  echo ">> Detected $$os. Patching /etc/hosts (sudo may prompt)..."; \
	  if ! grep -q "vault.local.danipa.com" /etc/hosts 2>/dev/null; then \
	    sudo sh -c 'printf "\\n# Danipa Fintech Platform (added by make hosts-patch)\\n" >> /etc/hosts'; \
	    sudo sh -c 'cat $(HOSTS_SNIPPET) >> /etc/hosts'; \
	    echo "✓ /etc/hosts updated"; \
	  else \
	    echo "✓ Entries already present in /etc/hosts"; \
	  fi; \
	else \
	  echo ">> Non-Unix or unknown OS detected. Please patch hosts manually with admin privileges."; \
	  echo "   Open this file and append its contents to your system hosts file:"; \
	  echo "     $(HOSTS_SNIPPET)"; \
	  echo "   Windows path: C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts"; \
	fi

.PHONY: hosts-show
hosts-show: ## Show current host mappings for Danipa domains (from /etc/hosts)
	@grep -E 'danipa\.com' /etc/hosts || echo "(no danipa.com entries in /etc/hosts)"

##@ Developer QoL
.PHONY: dev-up-fast
dev-up-fast: up-core wait-core health ## Bring up core, wait, and run health checks

.PHONY: e2e
e2e: dev-up-fast secrets-dev ## Bring up + seed dev secrets
